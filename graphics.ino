///  This whole program is for the adafruit ILI9341 display.
//  It was originally desinged for a display that would not have additional vram, 
// (the only difference being that the arduino can now display color, and only updates
//  changed characters)
//  so now it can be easily converted back into a monochrome 320 x 240 character
//  based display. 
//  
//  HOW IT WORKS:
//  the arduino stores a 30x40 byte array which represent the characters on display.
//  when it recieves "m" it assumes the rest of the input is 3 digits for x pos,
//  3 digits for y pos, and 3 digits for the character. (all in base ten)
//  in addition, the arduino stores an array called "color". the first value
//  corresponds to the color black, while the second value corresponds to white.
//  by inputing "c 2016" you can change the color of white. 
//  doing this before an update would change all newly displayed characters to green
//  but doing it while the arduino continues to draw allows an effect similar
//  to a horizontal interupt. 
//
//  the "u" command tells the arduino to update all chars next frame.
//
//  the "s" command instructs the arduino to display all the characters
//  indicated by the "updates" array. 

#include "SPI.h"
#include "Adafruit_GFX.h"
#include "Adafruit_ILI9341.h"

#define TFT_DC 9
#define TFT_CS 10


Adafruit_ILI9341 gfx = Adafruit_ILI9341(TFT_CS, TFT_DC);



byte tilemap[30][40];

char input[5];
int iter = 0;
byte updates[20][2];




const byte PROGMEM font[][8] =
{
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 000 (.)
  {0x1C, 0x22, 0x41, 0x7F, 0x41, 0x41, 0x41, 0x00}, // Char 001 (.)
  {0x7E, 0x21, 0x2E, 0x21, 0x21, 0x21, 0x7E, 0x00}, // Char 002 (.)
  {0x3E, 0x41, 0x40, 0x40, 0x41, 0x42, 0x3C, 0x00}, // Char 003 (.)
  {0x7E, 0x21, 0x21, 0x21, 0x21, 0x22, 0x7C, 0x00}, // Char 004 (.)
  {0x7F, 0x21, 0x3C, 0x20, 0x20, 0x21, 0x7F, 0x00}, // Char 005 (.)
  {0x7F, 0x21, 0x3C, 0x20, 0x20, 0x20, 0x60, 0x00}, // Char 006 (.)
  {0x1E, 0x21, 0x40, 0x47, 0x41, 0x25, 0x19, 0x00}, // Char 007 (.)
  {0x41, 0x41, 0x7F, 0x41, 0x41, 0x41, 0x41, 0x00}, // Char 008 (.)
  {0x7F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7F, 0x00}, // Char 009 (.)
  {0x7F, 0x02, 0x02, 0x42, 0x42, 0x24, 0x18, 0x00}, // Char 010 (.)
  {0x61, 0x21, 0x3A, 0x24, 0x22, 0x21, 0x61, 0x00}, // Char 011 (.)
  {0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7F, 0x00}, // Char 012 (.)
  {0x63, 0x55, 0x55, 0x49, 0x49, 0x49, 0x41, 0x00}, // Char 013 (.)
  {0x71, 0x49, 0x49, 0x49, 0x49, 0x49, 0x47, 0x00}, // Char 014 (.)
  {0x1C, 0x22, 0x41, 0x41, 0x41, 0x22, 0x1C, 0x00}, // Char 015 (.)
  {0x7E, 0x21, 0x2E, 0x20, 0x20, 0x20, 0x60, 0x00}, // Char 016 (.)
  {0x1C, 0x22, 0x41, 0x49, 0x45, 0x22, 0x1D, 0x00}, // Char 017 (.)
  {0x7E, 0x21, 0x29, 0x26, 0x21, 0x21, 0x61, 0x00}, // Char 018 (.)
  {0x3E, 0x41, 0x3C, 0x02, 0x01, 0x41, 0x3E, 0x00}, // Char 019 (.)
  {0x7F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, // Char 020 (.)
  {0x41, 0x41, 0x41, 0x21, 0x21, 0x11, 0x0F, 0x00}, // Char 021 (.)
  {0x41, 0x22, 0x14, 0x14, 0x08, 0x08, 0x08, 0x00}, // Char 022 (.)
  {0x41, 0x49, 0x49, 0x49, 0x55, 0x55, 0x63, 0x00}, // Char 023 (.)
  {0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41, 0x00}, // Char 024 (.)
  {0x41, 0x36, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, // Char 025 (.)
  {0x7F, 0x41, 0x02, 0x1C, 0x20, 0x41, 0x7F, 0x00}, // Char 026 (.)
  {0x3E, 0x41, 0x06, 0x08, 0x08, 0x00, 0x08, 0x00}, // Char 027 (.)
  {0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00}, // Char 028 (.)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00}, // Char 029 (.)
  {0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00}, // Char 030 (.)
  {0x00, 0x08, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00}, // Char 031 (.)
  {0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00}, // Char 032 ( )
  {0x08, 0x08, 0x08, 0x7F, 0x08, 0x08, 0x08, 0x00}, // Char 033 (!)
  {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00}, // Char 034 (")
  {0x21, 0x52, 0x24, 0x08, 0x12, 0x25, 0x42, 0x00}, // Char 035 (#)
  {0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 036 ($)
  {0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, // Char 037 (%)
  {0x18, 0x24, 0x18, 0x25, 0x22, 0x25, 0x19, 0x00}, // Char 038 (&)
  {0x0C, 0x10, 0x10, 0x20, 0x10, 0x10, 0x0C, 0x00}, // Char 039 (')
  {0x30, 0x08, 0x08, 0x04, 0x08, 0x08, 0x30, 0x00}, // Char 040 (()
  {0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x00}, // Char 041 ())
  {0x10, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x00}, // Char 042 (*)
  {0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x18, 0x00}, // Char 043 (+)
  {0x18, 0x08, 0x08, 0x08, 0x08, 0x08, 0x18, 0x00}, // Char 044 (,)
  {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00}, // Char 045 (-)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00}, // Char 046 (.)
  {0x2A, 0x1C, 0x1C, 0x2A, 0x00, 0x00, 0x00, 0x00}, // Char 047 (/)
  {0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x00, 0x00}, // Char 048 (0)
  {0x3E, 0x41, 0x4D, 0x55, 0x5D, 0x44, 0x33, 0x00}, // Char 049 (1)
  {0x00, 0x0C, 0x30, 0x40, 0x30, 0x0C, 0x00, 0x00}, // Char 050 (2)
  {0x00, 0x30, 0x0C, 0x02, 0x0C, 0x30, 0x00, 0x00}, // Char 051 (3)
  {0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 052 (4)
  {0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 053 (5)
  {0x01, 0x01, 0x11, 0x21, 0x7F, 0x20, 0x10, 0x00}, // Char 054 (6)
  {0x08, 0x1C, 0x2A, 0x08, 0x08, 0x08, 0x08, 0x00}, // Char 055 (7)
  {0x00, 0x04, 0x02, 0x7F, 0x02, 0x04, 0x00, 0x00}, // Char 056 (8)
  {0x08, 0x08, 0x08, 0x08, 0x2A, 0x1C, 0x08, 0x00}, // Char 057 (9)
  {0x00, 0x10, 0x20, 0x7F, 0x20, 0x10, 0x00, 0x00}, // Char 058 (:)
  {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // Char 059 (;)
  {0xDD, 0xFF, 0x77, 0xFF, 0xDD, 0xFF, 0x77, 0xFF}, // Char 060 (<)
  {0xDD, 0xAA, 0x77, 0xAA, 0xDD, 0xAA, 0x77, 0xAB}, // Char 061 (=)
  {0xDD, 0xAA, 0x55, 0xAA, 0xDD, 0xAA, 0x55, 0xAB}, // Char 062 (>)
  {0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA}, // Char 063 (?)
  {0x22, 0x55, 0xAA, 0x55, 0x22, 0x55, 0xAA, 0x54}, // Char 064 (@)
  {0x22, 0x55, 0x88, 0x55, 0x22, 0x55, 0x88, 0x54}, // Char 065 (A)
  {0x22, 0x00, 0x88, 0x00, 0x22, 0x00, 0x88, 0x00}, // Char 066 (B)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 067 (C)
  {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55}, // Char 068 (D)
  {0x22, 0x22, 0x44, 0x44, 0x88, 0x88, 0x11, 0x11}, // Char 069 (E)
  {0x44, 0x88, 0x11, 0x22, 0x44, 0x88, 0x11, 0x22}, // Char 070 (F)
  {0x0C, 0x30, 0xC0, 0x03, 0x0C, 0x30, 0xC0, 0x03}, // Char 071 (G)
  {0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF}, // Char 072 (H)
  {0x03, 0xC0, 0x30, 0x0C, 0x03, 0xC0, 0x30, 0x0C}, // Char 073 (I)
  {0x22, 0x11, 0x88, 0x44, 0x22, 0x11, 0x88, 0x44}, // Char 074 (J)
  {0x44, 0x44, 0x22, 0x22, 0x11, 0x11, 0x88, 0x88}, // Char 075 (K)
  {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}, // Char 076 (L)
  {0x7E, 0xC3, 0xA5, 0x81, 0xBD, 0x99, 0xC3, 0x7E}, // Char 077 (M)
  {0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33}, // Char 078 (N)
  {0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F}, // Char 079 (O)
  {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // Char 080 (P)
  {0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // Char 081 (Q)
  {0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // Char 082 (R)
  {0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // Char 083 (S)
  {0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF}, // Char 084 (T)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF}, // Char 085 (U)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF}, // Char 086 (V)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}, // Char 087 (W)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 088 (X)
  {0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 089 (Y)
  {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 090 (Z)
  {0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 091 ([)
  {0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00}, // Char 092 (\)
  {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00}, // Char 093 (])
  {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00}, // Char 094 (^)
  {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00}, // Char 095 (_)
  {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // Char 096 (`)
  {0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE}, // Char 097 (a)
  {0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC}, // Char 098 (b)
  {0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8}, // Char 099 (c)
  {0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0}, // Char 100 (d)
  {0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0}, // Char 101 (e)
  {0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0}, // Char 102 (f)
  {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80}, // Char 103 (g)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 104 (h)
  {0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}, // Char 105 (i)
  {0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03}, // Char 106 (j)
  {0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07}, // Char 107 (k)
  {0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F}, // Char 108 (l)
  {0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F}, // Char 109 (m)
  {0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F}, // Char 110 (n)
  {0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F}, // Char 111 (o)
  {0x1C, 0x22, 0x45, 0x49, 0x51, 0x22, 0x1C, 0x00}, // Char 112 (p)
  {0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x3E, 0x00}, // Char 113 (q)
  {0x3E, 0x41, 0x41, 0x02, 0x0C, 0x30, 0x7F, 0x00}, // Char 114 (r)
  {0x3E, 0x41, 0x0E, 0x01, 0x01, 0x41, 0x3E, 0x00}, // Char 115 (s)
  {0x06, 0x0A, 0x12, 0x22, 0x7F, 0x02, 0x07, 0x00}, // Char 116 (t)
  {0x7F, 0x40, 0x7E, 0x01, 0x01, 0x41, 0x3E, 0x00}, // Char 117 (u)
  {0x3E, 0x41, 0x40, 0x7E, 0x41, 0x41, 0x3E, 0x00}, // Char 118 (v)
  {0x7F, 0x41, 0x06, 0x08, 0x1C, 0x08, 0x08, 0x00}, // Char 119 (w)
  {0x3E, 0x41, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00}, // Char 120 (x)
  {0x3E, 0x41, 0x41, 0x3F, 0x01, 0x41, 0x3E, 0x00}, // Char 121 (y)
  {0x32, 0x55, 0x15, 0x15, 0x12, 0x10, 0x7C, 0x00}, // Char 122 (z)
  {0x32, 0x56, 0x12, 0x12, 0x17, 0x10, 0x7C, 0x00}, // Char 123 ({)
  {0x32, 0x55, 0x11, 0x12, 0x17, 0x10, 0x7C, 0x00}, // Char 124 (|)
  {0x36, 0x51, 0x16, 0x11, 0x16, 0x10, 0x7C, 0x00}, // Char 125 (})
  {0x30, 0x55, 0x17, 0x11, 0x11, 0x10, 0x7C, 0x00}, // Char 126 (~)
  {0x37, 0x54, 0x16, 0x11, 0x16, 0x10, 0x7C, 0x00}, // Char 127 (.)
  
};





const byte  PROGMEM charset2[][8] = {
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},
  {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},
  {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80},
  {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01},
  {0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f,0xff},
  {0xff,0x7f,0x3f,0x1f,0x0f,0x07,0x03,0x01},
  {0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff},
  {0xff,0xfe,0xfc,0xf8,0xf0,0xe0,0xc0,0x80},
  {0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00},
  {0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55},
  {0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00},
  {0xc3,0xe7,0x7e,0x3c,0x3c,0x7e,0xe7,0xc3},
  {0x00,0x00,0x00,0x00,0xf0,0x00,0x00,0x00},
  {0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00},
  {0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00},
  {0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08},

  };

const byte  PROGMEM charset3[][8] = {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0010 (0)
  { 0xFE, 0x01, 0x01, 0xFE, 0x01, 0x01, 0x02, 0xfc},   // weird thing
  { 0x3c, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3c},   // Circle
  { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0013 (3)
  { 0x18, 0x3C, 0x66, 0xc3, 0xc3, 0x66, 0x3c, 0x18},   // diamond
  { 0x99, 0x66, 0x99, 0x66, 0x99, 0x66, 0x99, 0x66},   // low rez checkeboard
  { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55},   // highrez cjecekerboard
  { 0xFF, 0xAA, 0xFF, 0xAA, 0xFF, 0xAA, 0xFF, 0xAA},   // 3/4 pattern
  { 0xCC, 0x99, 0x33, 0x66, 0x33, 0xCC, 0x99, 0x33},   // slashes
  { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0019 (9)
  { 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18},   // lower half dot
  { 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00},   // top right square
  { 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f},   // bottom right square
  { 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0},   // bottom left square
  { 0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00}    // top left square
};

const byte  PROGMEM charset4[][8] = { // boxes
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+2581 (box 1/8)
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF},   // U+2582 (box 2/8)
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF},   // U+2583 (box 3/8)
  { 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2584 (bottom half)
  { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2585 (box 5/8)
  { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2586 (box 6/8)
  { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2587 (box 7/8)   
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2588 (solid)
  { 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F},   // U+2589 (box 7/8)
  { 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F},   // U+258A (box 6/8)
  { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F},   // U+258B (box 5/8)
  { 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F},   // U+258C (left half)
  { 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07},   // U+258D (box 3/8)
  { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03},   // U+258E (box 2/8)
  { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}   // U+258F (box 1/8)  
};



const byte PROGMEM xor_font[][8] =
{
  {0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0}, // Char 000 (.)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF}, // Char 001 (.)
  {0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03}, // Char 002 (.)
  {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 003 (.)
  {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00}, // Char 004 (.)
  {0x00, 0x00, 0x00, 0x1F, 0x1F, 0x00, 0x00, 0x00}, // Char 005 (.)
  {0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18}, // Char 006 (.)
  {0x00, 0x00, 0x00, 0xF8, 0xF8, 0x00, 0x00, 0x00}, // Char 007 (.)
  {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, // Char 008 (.)
  {0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00}, // Char 009 (.)
  {0x01, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0}, // Char 010 (.)
  {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01}, // Char 011 (.)
  {0x3C, 0x7E, 0xE7, 0xC3, 0xC3, 0xE7, 0x7E, 0x3C}, // Char 012 (.)
  {0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0x3C}, // Char 013 (.)
  {0x30, 0x70, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x00}, // Char 014 (.)
  {0x0C, 0x0E, 0x0F, 0x0F, 0x07, 0x03, 0x00, 0x00}, // Char 015 (.)
  {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // Char 016 (.)
  {0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F}, // Char 017 (.)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E}, // Char 018 (.)
  {0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0}, // Char 019 (.)
  {0x00, 0x80, 0xC0, 0xE0, 0xE0, 0xC0, 0x80, 0x00}, // Char 020 (.)
  {0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00}, // Char 021 (.)
  {0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 022 (.)
  {0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00}, // Char 023 (.)
  {0x00, 0x01, 0x03, 0x07, 0x07, 0x03, 0x01, 0x00}, // Char 024 (.)
  {0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF}, // Char 025 (.)
  {0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF}, // Char 026 (.)
  {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80}, // Char 027 (.)
  {0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01}, // Char 028 (.)
  {0x7E, 0x81, 0xA5, 0x81, 0xFF, 0xC3, 0x7E, 0x3C}, // Char 029 (.)
  {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55}, // Char 030 (.)
  {0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF}, // Char 031 (.)
  
};


int out_color=0xFFFF;








bool screenupdate = false;
//byte colors[30][5];

byte graphics_mode=1;
int cursorpos=0;
bool Serial_active;

byte scale=1;
byte cull=1;

void setup() {
  pinMode(7, OUTPUT);
  gfx.begin();
  pinMode(2,INPUT);
  Serial.setTimeout(3);
  //gfx.select_font(font);
  // put your setup code here, to run once:
  gfx.fillScreen(0x0000);
  //pinMode(14,OUTPUT);



    Serial.println('D');
    memset(input, 0, sizeof(input));
    Serial.println('S');
    for(int i=0;i<1;i++){
    Serial.println('e');
    }

    delay(100);
    for(int i=0;i<1;i++){
    Serial.println('U');
    }

   

}

void loop() {

  digitalWrite(7,digitalRead(2));

  if(digitalRead(2)==HIGH){
    Serial.begin(115200);
    Serial.readBytes(input,5);
    Serial_active=true;
  }
  else{
    if(Serial_active==true){
      Serial.end();
      Serial_active=false;
    }
  }
  if(input[0]!=0){
   //Serial.println(input);
  }
  
  if (screenupdate) {
  //digitalWrite(7, HIGH);

   for (byte y = 0; y < 40; y++) {
        for (byte x = 0; x < 30; x++) {

          if (bitRead(updates[byte(y/2)][byte(x / 16)], byte(x/2) % 8)) {
          
            byte tile = tilemap[x][y];
            
            
              for (byte y2=0;y2<8;y2++){
                for (byte x2=0;x2<8;x2++){
                  byte pix1;
                  byte pix2;
                  byte out1;
                  byte out2;
                  switch(graphics_mode){
                  case 1:
                    pix1 = pgm_read_byte_near(&font[tile][y2]);
                    
                    out1 = bitRead(pix1, 7-x2 );
                    if (out1){out_color=0xFFFF;}
                    else{out_color=0x0000;}

                  break;

                  
                  case 2:
                    pix1 = pgm_read_byte_near(&font[tile/16][y2]);
                    out1 = bitRead(pix1, 7-x2 );
                    
                    pix2 = pgm_read_byte_near(&font[tile%16][y2]);
                    out2 = bitRead(pix2, 7-x2 );
                    if (out1^out2){out_color=0xFFFF;}
                    else{out_color=0x0000;}

                  break;  
                  
                  case 3:
                    
                  
                   if((tile>>4)-(tile%16)>0){
                    
                      pix1 = pgm_read_byte_near(&charset2[(0+tile)/16][y2]);
  
                      pix2 = pgm_read_byte_near(&charset2[(0+tile)%16][y2]);
                   }
                   else{
                     pix1 = pgm_read_byte_near(&charset3[(0+tile)/16][y2]);
  
                     pix2 = pgm_read_byte_near(&charset3[(0+tile)%16][y2]);}
                      
                    out1 = bitRead(pix1, x2 );
                    out2 = bitRead(pix2, x2 );
                    if (out1^out2){out_color=0xFFFF;}
                    else{out_color=0x0000;}
                    
                  break;
                  case 5:

                    out_color=0;
                    out_color=tile | tile<<8;
                    
                   
                  break;
                  case 6:


                    
                     pix1 = pgm_read_byte_near(&charset4[tile%16][y2]);
                     pix2 = pgm_read_byte_near(&charset4[tile/16][y2]);
                    
                    out1 = bitRead(pix1 | pix2, x2 );
                    if (out1){out_color=0xFFFF;}
                    else{out_color=0x0000;}
                    
                  break;
                  case 7:
                   
                   //Serial.print(tile>>4, HEX); Serial.print(" ");
                   //Serial.println(tile%16, HEX);
                   if((tile>>4)-(tile%16)>0 && tile>0){
                    
                      pix1 = pgm_read_byte_near(&xor_font[(0+tile)/16][y2]);
  
                     pix2 = pgm_read_byte_near(&xor_font[(0+tile)%16 ][y2]);
                   }
                   else if(tile>0){
                     
                     pix1 = pgm_read_byte_near(&xor_font[((0+tile)/16) + 16][y2]);
  
                     pix2 = pgm_read_byte_near(&xor_font[((0+tile)%16) + 16][y2]);} else{pix1=0; pix2 = 0; 
                   }
                      
                    out1 = bitRead(pix1, x2 );
                    out2 = bitRead(pix2, x2 );
                    if(tile/16 == tile%16){
                      if(out1){out_color=0xFFFF;} else {out_color=0x0000; } 
                    }
                    else if (  out1^out2 ){out_color=0xFFFF;}
                    else{out_color=0x0000;} 
                    
                  break;
                  }
                  gfx.fillRect( (x*8+x2)*scale, (y*8+y2)*scale,scale,scale, out_color);
                }  
              }
            }
        
          
        }
        //Serial.readBytes(input,15);
//        if (input[0]=='c') {
//          color[1][0]=input[1];
//          color[1][1]=input[2];
//          color[1][2]=input[3];
//          //Serial.println(colmor[1]);
//        }
        

    }
    //Serial.println('U');
    screenupdate = false;
    memset(updates, 0, sizeof(updates));
    //Serial.println('D');
    //digitalWrite(7,LOW);
  }

  

  //if (input[0]!=0){for(byte i=0; i<8;i++){Serial.println(String(byte(input[i])));}}
  if (input[0]==109){// Command: "mxyt"
      
      byte x = (input[1])%(byte)(30/cull);
      byte y = (input[2])%(byte)(40/cull);
      byte t = input[3];
      
      tilemap[x][y] = t;
      bitSet(updates[y/2][x/16], (x/2) % 8);
//      if(graphics_mode>=4){
//        bitSet(updates[y/2][((x+15)%30)/16 ], ((x+15)%30)/2 );
//        bitSet(updates[((y+20)%40)/2][((x)%30)/16 ], ((x)%30)/2 );
//        bitSet(updates[((y+20)%40)/2][((x+15)%30)/16 ], ((x+15)%30)/2 );              
//      }
      
      //Serial.println('S');
      //graphics_mode=(graphics_mode+1)%6;

      
  }
    if (input[0]=='g'){// Command: "gxy"
      byte x = (input[1])%(byte)(30/cull);
      byte y = (input[2])%(byte)(40/cull);
      Serial.print('T');
      Serial.print(tilemap[x][y]);

      
  }

  if (input[0]=='A'){// Command: "Ax"
      graphics_mode=input[1];     
  }
//  if (input[0]=='C'){// Command: "C" //toggle twice cull
//      cull++;    
//  }

  if (input[0]=='s'){
      screenupdate = true;
      //memset(updates, 255, sizeof(updates));
      //Serial.println('U');
      
   }
  memset(input, 0, sizeof(input));
  //digitalWrite(7, LOW);
}
